<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Temple Run: Ekansh vs KAJU KATTRI</title>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
<style>
  html,body { margin:0; padding:0; height:100%; background:#000; overflow:hidden; }
  #ui { position:fixed; bottom:18px; left:50%; transform:translateX(-50%); z-index:30; display:flex; gap:18px; pointer-events:auto; }
  .btn { width:84px; height:84px; border-radius:50%; border: none; background: rgba(0,0,0,0.45); color:#fff; font-size:28px; box-shadow:0 6px 18px rgba(0,0,0,0.6); }
  .btn:active { transform:scale(.96); background:#00c853; color:#000; }
  #jumpBtn { width:92px; height:92px; font-size:30px; }
  #restart { display:none; position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); z-index:40; padding:14px 26px; font-size:20px; border-radius:12px; border:none; background:#00c853; color:#000; box-shadow:0 10px 30px rgba(0,200,83,0.25); }
  #hud { position:fixed; left:12px; top:12px; z-index:40; color:#fff; font-family:Arial, sans-serif; text-shadow:0 2px 6px rgba(0,0,0,0.7); }
  #best { font-size:14px; color:#ffeb3b; margin-top:4px; }
  /* Make buttons large on small screens */
  @media (max-width:420px){ #ui{ gap:12px } .btn{ width:72px; height:72px; font-size:22px } #jumpBtn{ width:80px;height:80px } }
</style>
</head>
<body>

<!-- Touch controls -->
<div id="ui" style="display:none;">
  <button id="leftBtn" class="btn">‚¨ÖÔ∏è</button>
  <button id="jumpBtn" class="btn">‚è´</button>
  <button id="rightBtn" class="btn">‚û°Ô∏è</button>
</div>

<button id="restart">üîÅ Restart</button>
<div id="hud" style="display:none;">
  <div id="score" style="font-size:20px">Score: 0</div>
  <div id="best">Best: 0</div>
</div>

<script>
/*
  Temple Run-like Phaser 3 mobile game.
  Requires these image files in same folder as index.html:
    - bg.png        (background tile for parallax)
    - player.png    (player image; ideally facing forward)
    - monster.png   (monster that chases)
    - coin.png      (coin image)
    - obstacle.png  (obstacle image)
*/

const LOCAL_FILES = {
  bg: 'bg.png',
  player: 'player.png',
  monster: 'monster.png',
  coin: 'coin.png',
  obstacle: 'obstacle.png'
};

class BootScene extends Phaser.Scene {
  constructor(){ super('BootScene'); }
  preload(){
    // load local images
    Object.keys(LOCAL_FILES).forEach(k => this.load.image(k, LOCAL_FILES[k]));
    // small audio assets (optional online)
    this.load.audio('coin', 'https://cdn.pixabay.com/download/audio/2021/09/14/audio_6c84a49a03.mp3?filename=collect-coin-1-190131.mp3');
    this.load.audio('jump', 'https://cdn.pixabay.com/download/audio/2021/09/07/audio_3b6c6d7c22.mp3?filename=jump-142094.mp3');
  }
  create(){ this.scene.start('StartScene'); }
}

class StartScene extends Phaser.Scene {
  constructor(){ super('StartScene'); }
  create(){
    const w = this.scale.width, h = this.scale.height;
    // dark blurred background to show the title
    const rect = this.add.rectangle(w/2, h/2, w*0.9, h*0.7, 0x000000, 0.45).setOrigin(0.5);
    this.add.text(w/2, h/2 - 60, 'Temple Run', {fontSize: '44px', fill:'#00ff00'}).setOrigin(0.5);
    this.add.text(w/2, h/2 - 6, 'Ekansh vs KAJU KATTRI', {fontSize:'20px', fill:'#fff'}).setOrigin(0.5);
    this.add.text(w/2, h/2 + 50, 'Tap to Play (or swipe to move)', {fontSize:'18px', fill:'#ddd'}).setOrigin(0.5);

    // ensure UI shown
    document.getElementById('ui').style.display = 'flex';
    document.getElementById('hud').style.display = 'block';

    this.input.once('pointerdown', () => {
      this.scene.start('GameScene');
    });
  }
}

class GameScene extends Phaser.Scene {
  constructor(){ super('GameScene'); }
  create(){
    // show UI
    document.getElementById('ui').style.display = 'flex';
    document.getElementById('hud').style.display = 'block';
    document.getElementById('restart').style.display = 'none';

    const w = this.scale.width, h = this.scale.height;

    // parallax background using tileSprite
    this.bg = this.add.tileSprite(w/2, h/2, w, h, 'bg');

    // lanes 3 positions (responsive)
    this.lanesX = [ w*0.25, w*0.5, w*0.75 ];
    this.playerLane = 1;

    // game parameters
    this.groundY = h - Math.max(120, Math.round(h * 0.18));
    this.speed = 280;                // vertical spawn speed (px/s)
    this.spawnRate = 1600;          // spawn ms base
    this.coinRate = 1000;
    this.score = 0;
    this.best = Number(localStorage.getItem('tr_best')||0);
    document.getElementById('best').textContent = 'Best: ' + this.best;

    // physics groups
    this.obstacles = this.physics.add.group();
    this.coins = this.physics.add.group();

    // player sprite
    this.player = this.physics.add.sprite(this.lanesX[this.playerLane], this.groundY, 'player');
    this.player.setScale(Math.min(1.1, (w/800)));
    this.player.setDepth(3);
    this.player.setCollideWorldBounds(true);
    this.player.body.setGravityY(1400);
    this.isGameOver = false;

    // small hop animation to look alive
    this.tweens.add({
      targets: this.player,
      y: this.groundY - 4,
      yoyo: true,
      repeat: -1,
      duration: 600,
      ease: 'Sine.easeInOut'
    });

    // monster (chaser)
    this.monster = this.add.sprite(this.lanesX[0], this.groundY + 40, 'monster');
    this.monster.setScale(this.player.scale * 0.95);
    this.monster.setDepth(2);

    // audio
    this.coinS = this.sound.add('coin', {volume:0.5});
    this.jumpS = this.sound.add('jump', {volume:0.5});

    // HUD score
    this.scoreText = document.getElementById('score');
    this.updateScoreText();

    // spawn timed events
    this.obstacleTimer = this.time.addEvent({ delay: this.spawnRate, loop:true, callback: this.spawnObstacle, callbackScope: this });
    this.coinTimer = this.time.addEvent({ delay: this.coinRate, loop:true, callback: this.spawnCoin, callbackScope: this });

    // collisions
    this.physics.add.overlap(this.player, this.coins, this.collectCoin, null, this);
    this.physics.add.overlap(this.player, this.obstacles, this.onHitObstacle, null, this);

    // controls: touch buttons
    document.getElementById('leftBtn').onclick = ()=> this.moveLeft();
    document.getElementById('rightBtn').onclick = ()=> this.moveRight();
    document.getElementById('jumpBtn').onclick = ()=> this.jump();

    // swipe detection for lane change / jump
    this.input.on('pointerdown', (p) => { this.swipeStart = { x:p.x, y:p.y, t: Date.now() }; });
    this.input.on('pointerup', (p) => {
      if (!this.swipeStart) return;
      const dx = p.x - this.swipeStart.x, dy = p.y - this.swipeStart.y;
      const dt = Date.now() - this.swipeStart.t;
      this.swipeStart = null;
      // require some minimum distance and reasonable time
      if (Math.abs(dx) > 40 && Math.abs(dx) > Math.abs(dy) && dt < 400) {
        if (dx > 0) this.moveRight(); else this.moveLeft();
      } else if (dy < -60 && Math.abs(dy) > Math.abs(dx)) {
        // swipe up
        this.jump();
      } else {
        // tap: small forward dash (optional) -> we'll just jump small if on ground
        if (this.player.body.blocked.down) { this.jump(); }
      }
    });

    // hide mobile keyboard and request orientation fullscreen hint (optional)
    // gradually increase difficulty over time
    this.difficultyTimer = this.time.addEvent({ delay: 5000, loop:true, callback: () => {
      this.speed = Math.min(800, this.speed + 30);
      // reduce spawn delay gradually
      this.obstacleTimer.delay = Math.max(700, this.obstacleTimer.delay - 80);
      this.coinTimer.delay = Math.max(500, this.coinTimer.delay - 30);
    }, callbackScope: this });

    // ensure camera bounds (no camera movement, visual only)
    this.cursors = this.input.keyboard.createCursorKeys(); // not used on mobile but harmless

    // make sure game runs at high priority on mobile
    this.game.loop.targetFps = 60;
  }

  spawnObstacle(){
    if (this.isGameOver) return;
    const lane = Phaser.Math.Between(0,2);
    const x = this.lanesX[lane];
    const obs = this.obstacles.create(x, -60, 'obstacle');
    // scale relative to screen
    obs.setScale(this.player.scale * 0.9);
    obs.body.setAllowGravity(false);
    obs.setDepth(2);
    // set velocity downwards to simulate forward movement
    obs.body.setVelocityY(this.speed);
    // ensure collision size ok
    obs.body.setSize(obs.width * 0.8, obs.height * 0.8);
  }

  spawnCoin(){
    if (this.isGameOver) return;
    const lane = Phaser.Math.Between(0,2);
    const x = this.lanesX[lane];
    const coin = this.coins.create(x, -40, 'coin');
    coin.setScale(Math.max(0.6, this.player.scale*0.6));
    coin.body.setAllowGravity(false);
    coin.setDepth(2);
    coin.body.setVelocityY(this.speed * 0.9);
  }

  collectCoin(player, coin){
    if (!coin.active) return;
    coin.destroy();
    this.score += 10;
    this.updateScoreText();
    if (this.coinS) this.coinS.play();
  }

  onHitObstacle(){
    // If player is jumping over obstacle (hit from above) ignore; else game over
    if (this.isGameOver) return;
    const hit = () => {
      this.endGame();
    };
    // Check vertical overlap: if player's bottom is above obstacle top by some margin => passed
    // But Arcade overlap already triggered; do a bounding box check
    // We'll consider it collision always to keep it simple (player must jump over obstacle's y)
    hit();
  }

  moveLeft(){
    if (this.isGameOver) return;
    if (this.playerLane > 0){
      this.playerLane--;
      this.tweens.add({ targets: this.player, x: this.lanesX[this.playerLane], duration: 160, ease:'Cubic.easeOut' });
    }
  }

  moveRight(){
    if (this.isGameOver) return;
    if (this.playerLane < 2){
      this.playerLane++;
      this.tweens.add({ targets: this.player, x: this.lanesX[this.playerLane], duration: 160, ease:'Cubic.easeOut' });
    }
  }

  jump(){
    if (this.isGameOver) return;
    if (this.player.body.blocked.down){
      this.player.setVelocityY(-650);
      if (this.jumpS) this.jumpS.play();
    }
  }

  endGame(){
    if (this.isGameOver) return;
    this.isGameOver = true;
    // stop timers
    this.obstacleTimer.paused = true;
    this.coinTimer.paused = true;
    this.difficultyTimer.paused = true;

    // hide controls & show restart
    document.getElementById('ui').style.display = 'none';
    const restartBtn = document.getElementById('restart');
    restartBtn.style.display = 'block';

    // show overlay text in canvas
    const w = this.scale.width, h = this.scale.height;
    this.add.rectangle(w/2, h/2, w*0.9, h*0.4, 0x000000, 0.55).setDepth(40);
    this.add.text(w/2, h/2 - 40, 'GAME OVER', { fontSize: '40px', fill: '#ff5252' }).setOrigin(0.5).setDepth(41);
    this.add.text(w/2, h/2 + 6, 'Tap Restart to Play Again', { fontSize: '18px', fill: '#fff' }).setOrigin(0.5).setDepth(41);

    // update best score
    if (this.score > this.best){
      this.best = Math.floor(this.score);
      localStorage.setItem('tr_best', this.best);
      document.getElementById('best').textContent = 'Best: ' + this.best;
    }

    restartBtn.onclick = () => {
      restartBtn.style.display = 'none';
      this.scene.restart();
    };
  }

  update(time, dt){
    if (this.isGameOver) return;
    // scroll background to create movement sensation
    const scrollSpeed = Math.min(6, this.speed / 120);
    this.bg.tilePositionY += scrollSpeed;

    // remove off-screen objects
    this.obstacles.getChildren().forEach(o => { if (o.y > this.scale.height + 80) o.destroy(); });
    this.coins.getChildren().forEach(c => { if (c.y > this.scale.height + 80) c.destroy(); });

    // monster follows slowly behind ‚Äî if monster reaches player's x and close y, game over
    const targetX = this.lanesX[Math.max(0, this.playerLane - 0)];
    this.monster.x = Phaser.Math.Linear(this.monster.x, targetX, 0.04);
    // move monster forward slowly
    this.monster.y = Phaser.Math.Linear(this.monster.y, this.player.y + 40, 0.01);

    // If any obstacle is too close to monster (player failed repeatedly), nudge monster forward
    const closestObs = this.obstacles.getChildren().reduce((min, o) => (o && (min==null || o.y < min.y)) ? o : min, null);
    if (closestObs && closestObs.y > this.scale.height*0.4) {
      // nudge
      this.monster.y += Phaser.Math.Clamp((closestObs.y - this.player.y) * 0.002, 0, 1.5);
    }

    // Catch: if monster gets close to player horizontally and vertically -> game over
    const dx = Math.abs(this.monster.x - this.player.x);
    const dy = Math.abs((this.monster.y) - (this.player.y));
    if (dx < 34 && dy < 80) {
      this.endGame();
    }

    // score increases by distance/time survived
    this.score += dt/1000 * 12; // tune this for pacing
    this.updateScoreText();
  }

  updateScoreText(){
    document.getElementById('score').textContent = 'Score: ' + Math.floor(this.score);
  }
}

// Game config scales to full mobile viewport
const config = {
  type: Phaser.AUTO,
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH,
    width: window.innerWidth,
    height: window.innerHeight
  },
  backgroundColor: '#111111',
  physics: { default: 'arcade', arcade: { gravity: { y: 0 }, debug: false } },
  scene: [BootScene, StartScene, GameScene]
};

// create game
const game = new Phaser.Game(config);

// Prevent screen from zooming and keep viewport stable
window.addEventListener('resize', () => {
  game.scale.resize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
